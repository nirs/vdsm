#!/usr/bin/python2
#
# Copyright 2014-2017 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Refer to the README and COPYING files for full details of the license
#

"""
Usage: fc-scan [-v|-h] [--no-devices]

Perform SCSI scan on Fibre Channel scsi_hosts and devices, adding new LUNs and
updating sizes of existing devices. This procedure will not remove existing
LUNs. Must run as root.

Options:
  -v            enable verbose logging
  -h            display this help and exit
  --no-devices  do not scan devices

Exit codes:
  0         scanned fc_hosts and devices successfully
  1         scanning some hosts or devices failed
"""

from __future__ import absolute_import
from __future__ import print_function

import glob
import logging
import os
import random
import sys

from vdsm import utils
from vdsm.common import concurrent

log = logging.getLogger("fc-scan")

# This is just a starting value before we did any measurments.  It should be
# larger than number of fc_hosts, and large enough to allow parallel device
# rescanning.
MAX_WORKERS = 10


class Error(Exception):
    """
    Scanning hosts or devices failed.
    """


def main(args):
    if '-h' in args:
        print(__doc__)
        return

    should_rescan_devices = "--no-devices" not in args

    logging.basicConfig(
        level=logging.DEBUG if '-v' in args else logging.INFO,
        format="%(name)s: %(message)s")

    hosts = find_fc_hosts()
    if not hosts:
        log.debug("No fc_host found")
        return

    scan_hosts(hosts)

    if should_rescan_devices:
        rescan_devices(hosts)


# Scanning hosts.

def find_fc_hosts():
    return [os.path.basename(path)
            for path in glob.glob("/sys/class/fc_host/host*")]


def scan_hosts(hosts):
    results = concurrent.tmap(
        scan_scsi_host,
        hosts,
        max_workers=MAX_WORKERS,
        name="scan")

    if not all(res.value for res in results):
        raise Error("Scanning hosts failed")


def scan_scsi_host(host):
    try:
        path = "/sys/class/scsi_host/{}/scan".format(host)
        log.debug("Scanning %s", host)
        with utils.stopwatch("Scanned %s" % host, log=log):
            fd = os.open(path, os.O_WRONLY)
            try:
                os.write(fd, b"- - -")
            finally:
                os.close(fd)
        return True
    except OSError as e:
        log.error("Scanning %s failed: %s", host, e)
        return False
    except Exception:
        log.exception("Scanning %s failed", host)
        return False


# Rescanning fc devices.

def rescan_devices(hosts):
    devices = list(find_fc_devices(hosts))

    # Randomizing introduces a small delay for collecting all devices, but it
    # distributes scans evenly and may improve concurrency during scanning.
    random.shuffle(devices)

    results = concurrent.tmap(
        rescan_scsi_device,
        devices,
        max_workers=MAX_WORKERS,
        name="rescan")

    if not all(res.value for res in results):
        raise Error("Rescanning devices failed")


def find_fc_devices(hosts):
    hosts_paths = tuple(
        os.path.realpath("/sys/class/fc_host/{}/../..".format(host))
        for host in hosts)

    # Do we have a more efficient way to filter fc devices?
    for device_path in glob.iglob("/sys/class/scsi_device/*"):
        real_device_path = os.path.realpath(device_path)
        if real_device_path.startswith(hosts_paths):
            yield real_device_path


def rescan_scsi_device(device_path):
    try:
        rescan_path = os.path.join(device_path, "../../rescan")
        path = os.path.normpath(rescan_path)
        log.debug("Rescanning device %s", path)
        with utils.stopwatch("Rescanned device %s" % path, log=log):
            fd = os.open(path, os.O_WRONLY)
            try:
                os.write(fd, b"1")
            finally:
                os.close(fd)
        return True
    except OSError as e:
        log.error("Rescanning %s failed: %s", path, e)
        return False
    except Exception:
        log.exception("Rescanning %s failed", path)
        return False


if __name__ == '__main__':
    try:
        main(sys.argv[1:])
    except Error as e:
        log.error("%s", e)
        sys.exit(1)
